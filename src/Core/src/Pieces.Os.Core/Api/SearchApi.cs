/*
 * Pieces Isomorphic OpenAPI
 *
 * Endpoints for Assets, Formats, Users, Asset, Format, User.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: tsavo@pieces.app
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Pieces.Os.Core.Client;
using Pieces.Os.Core.Client.Auth;
using Pieces.Os.Core.SdkModel;

namespace Pieces.Os.Core.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISearchApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// /search/full_text [GET]
        /// </summary>
        /// <remarks>
        /// This will run FTS for exact search, and will NOT run fuzzy matching. This will only search the content within the 
        /// </remarks>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">This is a string that you can use to search your assets. (optional)</param>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SearchedAssets</returns>
        SearchedAssets FullTextSearch(string query = default(string), bool? pseudo = default(bool?), int operationIndex = 0);

        /// <summary>
        /// /search/full_text [GET]
        /// </summary>
        /// <remarks>
        /// This will run FTS for exact search, and will NOT run fuzzy matching. This will only search the content within the 
        /// </remarks>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">This is a string that you can use to search your assets. (optional)</param>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SearchedAssets</returns>
        ApiResponse<SearchedAssets> FullTextSearchWithHttpInfo(string query = default(string), bool? pseudo = default(bool?), int operationIndex = 0);
        /// <summary>
        /// /search/neural_code [GET]
        /// </summary>
        /// <remarks>
        /// This will run ncs on your assets. This will simply return FlattenedAssets, but will just be the assetuuids that match.
        /// </remarks>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">This is a string that you can use to search your assets. (optional)</param>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SearchedAssets</returns>
        SearchedAssets NeuralCodeSearch(string query = default(string), bool? pseudo = default(bool?), int operationIndex = 0);

        /// <summary>
        /// /search/neural_code [GET]
        /// </summary>
        /// <remarks>
        /// This will run ncs on your assets. This will simply return FlattenedAssets, but will just be the assetuuids that match.
        /// </remarks>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">This is a string that you can use to search your assets. (optional)</param>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SearchedAssets</returns>
        ApiResponse<SearchedAssets> NeuralCodeSearchWithHttpInfo(string query = default(string), bool? pseudo = default(bool?), int operationIndex = 0);
        /// <summary>
        /// /search/tag_based [POST]
        /// </summary>
        /// <remarks>
        /// This will run our tag based search, and return the assets that best match your passed in tags. This will simply return FlattenedAssets, but will just be the assetuuids that match.
        /// </remarks>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="seededAssetTags"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SearchedAssets</returns>
        SearchedAssets TagBasedSearch(bool? pseudo = default(bool?), SeededAssetTags seededAssetTags = default(SeededAssetTags), int operationIndex = 0);

        /// <summary>
        /// /search/tag_based [POST]
        /// </summary>
        /// <remarks>
        /// This will run our tag based search, and return the assets that best match your passed in tags. This will simply return FlattenedAssets, but will just be the assetuuids that match.
        /// </remarks>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="seededAssetTags"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SearchedAssets</returns>
        ApiResponse<SearchedAssets> TagBasedSearchWithHttpInfo(bool? pseudo = default(bool?), SeededAssetTags seededAssetTags = default(SeededAssetTags), int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISearchApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// /search/full_text [GET]
        /// </summary>
        /// <remarks>
        /// This will run FTS for exact search, and will NOT run fuzzy matching. This will only search the content within the 
        /// </remarks>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">This is a string that you can use to search your assets. (optional)</param>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SearchedAssets</returns>
        System.Threading.Tasks.Task<SearchedAssets> FullTextSearchAsync(string query = default(string), bool? pseudo = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// /search/full_text [GET]
        /// </summary>
        /// <remarks>
        /// This will run FTS for exact search, and will NOT run fuzzy matching. This will only search the content within the 
        /// </remarks>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">This is a string that you can use to search your assets. (optional)</param>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SearchedAssets)</returns>
        System.Threading.Tasks.Task<ApiResponse<SearchedAssets>> FullTextSearchWithHttpInfoAsync(string query = default(string), bool? pseudo = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// /search/neural_code [GET]
        /// </summary>
        /// <remarks>
        /// This will run ncs on your assets. This will simply return FlattenedAssets, but will just be the assetuuids that match.
        /// </remarks>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">This is a string that you can use to search your assets. (optional)</param>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SearchedAssets</returns>
        System.Threading.Tasks.Task<SearchedAssets> NeuralCodeSearchAsync(string query = default(string), bool? pseudo = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// /search/neural_code [GET]
        /// </summary>
        /// <remarks>
        /// This will run ncs on your assets. This will simply return FlattenedAssets, but will just be the assetuuids that match.
        /// </remarks>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">This is a string that you can use to search your assets. (optional)</param>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SearchedAssets)</returns>
        System.Threading.Tasks.Task<ApiResponse<SearchedAssets>> NeuralCodeSearchWithHttpInfoAsync(string query = default(string), bool? pseudo = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// /search/tag_based [POST]
        /// </summary>
        /// <remarks>
        /// This will run our tag based search, and return the assets that best match your passed in tags. This will simply return FlattenedAssets, but will just be the assetuuids that match.
        /// </remarks>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="seededAssetTags"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SearchedAssets</returns>
        System.Threading.Tasks.Task<SearchedAssets> TagBasedSearchAsync(bool? pseudo = default(bool?), SeededAssetTags seededAssetTags = default(SeededAssetTags), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// /search/tag_based [POST]
        /// </summary>
        /// <remarks>
        /// This will run our tag based search, and return the assets that best match your passed in tags. This will simply return FlattenedAssets, but will just be the assetuuids that match.
        /// </remarks>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="seededAssetTags"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SearchedAssets)</returns>
        System.Threading.Tasks.Task<ApiResponse<SearchedAssets>> TagBasedSearchWithHttpInfoAsync(bool? pseudo = default(bool?), SeededAssetTags seededAssetTags = default(SeededAssetTags), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ISearchApi : ISearchApiSync, ISearchApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class SearchApi : ISearchApi
    {
        private Pieces.Os.Core.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="SearchApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SearchApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SearchApi"/> class.
        /// </summary>
        /// <returns></returns>
        public SearchApi(string basePath)
        {
            this.Configuration = Pieces.Os.Core.Client.Configuration.MergeConfigurations(
                Pieces.Os.Core.Client.GlobalConfiguration.Instance,
                new Pieces.Os.Core.Client.Configuration { BasePath = basePath }
            );
            this.Client = new Pieces.Os.Core.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Pieces.Os.Core.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Pieces.Os.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SearchApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public SearchApi(Pieces.Os.Core.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Pieces.Os.Core.Client.Configuration.MergeConfigurations(
                Pieces.Os.Core.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new Pieces.Os.Core.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Pieces.Os.Core.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Pieces.Os.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SearchApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public SearchApi(Pieces.Os.Core.Client.ISynchronousClient client, Pieces.Os.Core.Client.IAsynchronousClient asyncClient, Pieces.Os.Core.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Pieces.Os.Core.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Pieces.Os.Core.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Pieces.Os.Core.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Pieces.Os.Core.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Pieces.Os.Core.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// /search/full_text [GET] This will run FTS for exact search, and will NOT run fuzzy matching. This will only search the content within the 
        /// </summary>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">This is a string that you can use to search your assets. (optional)</param>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SearchedAssets</returns>
        public SearchedAssets FullTextSearch(string query = default(string), bool? pseudo = default(bool?), int operationIndex = 0)
        {
            Pieces.Os.Core.Client.ApiResponse<SearchedAssets> localVarResponse = FullTextSearchWithHttpInfo(query, pseudo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// /search/full_text [GET] This will run FTS for exact search, and will NOT run fuzzy matching. This will only search the content within the 
        /// </summary>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">This is a string that you can use to search your assets. (optional)</param>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SearchedAssets</returns>
        public Pieces.Os.Core.Client.ApiResponse<SearchedAssets> FullTextSearchWithHttpInfo(string query = default(string), bool? pseudo = default(bool?), int operationIndex = 0)
        {
            Pieces.Os.Core.Client.RequestOptions localVarRequestOptions = new Pieces.Os.Core.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/plain"
            };

            var localVarContentType = Pieces.Os.Core.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Pieces.Os.Core.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (query != null)
            {
                localVarRequestOptions.QueryParameters.Add(Pieces.Os.Core.Client.ClientUtils.ParameterToMultiMap("", "query", query));
            }
            if (pseudo != null)
            {
                localVarRequestOptions.QueryParameters.Add(Pieces.Os.Core.Client.ClientUtils.ParameterToMultiMap("", "pseudo", pseudo));
            }

            localVarRequestOptions.Operation = "SearchApi.FullTextSearch";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Get<SearchedAssets>("/search/full_text", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("FullTextSearch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// /search/full_text [GET] This will run FTS for exact search, and will NOT run fuzzy matching. This will only search the content within the 
        /// </summary>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">This is a string that you can use to search your assets. (optional)</param>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SearchedAssets</returns>
        public async System.Threading.Tasks.Task<SearchedAssets> FullTextSearchAsync(string query = default(string), bool? pseudo = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Pieces.Os.Core.Client.ApiResponse<SearchedAssets> localVarResponse = await FullTextSearchWithHttpInfoAsync(query, pseudo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// /search/full_text [GET] This will run FTS for exact search, and will NOT run fuzzy matching. This will only search the content within the 
        /// </summary>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">This is a string that you can use to search your assets. (optional)</param>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SearchedAssets)</returns>
        public async System.Threading.Tasks.Task<Pieces.Os.Core.Client.ApiResponse<SearchedAssets>> FullTextSearchWithHttpInfoAsync(string query = default(string), bool? pseudo = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Pieces.Os.Core.Client.RequestOptions localVarRequestOptions = new Pieces.Os.Core.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/plain"
            };

            var localVarContentType = Pieces.Os.Core.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Pieces.Os.Core.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (query != null)
            {
                localVarRequestOptions.QueryParameters.Add(Pieces.Os.Core.Client.ClientUtils.ParameterToMultiMap("", "query", query));
            }
            if (pseudo != null)
            {
                localVarRequestOptions.QueryParameters.Add(Pieces.Os.Core.Client.ClientUtils.ParameterToMultiMap("", "pseudo", pseudo));
            }

            localVarRequestOptions.Operation = "SearchApi.FullTextSearch";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<SearchedAssets>("/search/full_text", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("FullTextSearch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// /search/neural_code [GET] This will run ncs on your assets. This will simply return FlattenedAssets, but will just be the assetuuids that match.
        /// </summary>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">This is a string that you can use to search your assets. (optional)</param>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SearchedAssets</returns>
        public SearchedAssets NeuralCodeSearch(string query = default(string), bool? pseudo = default(bool?), int operationIndex = 0)
        {
            Pieces.Os.Core.Client.ApiResponse<SearchedAssets> localVarResponse = NeuralCodeSearchWithHttpInfo(query, pseudo);
            return localVarResponse.Data;
        }

        /// <summary>
        /// /search/neural_code [GET] This will run ncs on your assets. This will simply return FlattenedAssets, but will just be the assetuuids that match.
        /// </summary>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">This is a string that you can use to search your assets. (optional)</param>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SearchedAssets</returns>
        public Pieces.Os.Core.Client.ApiResponse<SearchedAssets> NeuralCodeSearchWithHttpInfo(string query = default(string), bool? pseudo = default(bool?), int operationIndex = 0)
        {
            Pieces.Os.Core.Client.RequestOptions localVarRequestOptions = new Pieces.Os.Core.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/plain"
            };

            var localVarContentType = Pieces.Os.Core.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Pieces.Os.Core.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (query != null)
            {
                localVarRequestOptions.QueryParameters.Add(Pieces.Os.Core.Client.ClientUtils.ParameterToMultiMap("", "query", query));
            }
            if (pseudo != null)
            {
                localVarRequestOptions.QueryParameters.Add(Pieces.Os.Core.Client.ClientUtils.ParameterToMultiMap("", "pseudo", pseudo));
            }

            localVarRequestOptions.Operation = "SearchApi.NeuralCodeSearch";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Get<SearchedAssets>("/search/neural_code", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("NeuralCodeSearch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// /search/neural_code [GET] This will run ncs on your assets. This will simply return FlattenedAssets, but will just be the assetuuids that match.
        /// </summary>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">This is a string that you can use to search your assets. (optional)</param>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SearchedAssets</returns>
        public async System.Threading.Tasks.Task<SearchedAssets> NeuralCodeSearchAsync(string query = default(string), bool? pseudo = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Pieces.Os.Core.Client.ApiResponse<SearchedAssets> localVarResponse = await NeuralCodeSearchWithHttpInfoAsync(query, pseudo, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// /search/neural_code [GET] This will run ncs on your assets. This will simply return FlattenedAssets, but will just be the assetuuids that match.
        /// </summary>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="query">This is a string that you can use to search your assets. (optional)</param>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SearchedAssets)</returns>
        public async System.Threading.Tasks.Task<Pieces.Os.Core.Client.ApiResponse<SearchedAssets>> NeuralCodeSearchWithHttpInfoAsync(string query = default(string), bool? pseudo = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Pieces.Os.Core.Client.RequestOptions localVarRequestOptions = new Pieces.Os.Core.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/plain"
            };

            var localVarContentType = Pieces.Os.Core.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Pieces.Os.Core.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (query != null)
            {
                localVarRequestOptions.QueryParameters.Add(Pieces.Os.Core.Client.ClientUtils.ParameterToMultiMap("", "query", query));
            }
            if (pseudo != null)
            {
                localVarRequestOptions.QueryParameters.Add(Pieces.Os.Core.Client.ClientUtils.ParameterToMultiMap("", "pseudo", pseudo));
            }

            localVarRequestOptions.Operation = "SearchApi.NeuralCodeSearch";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<SearchedAssets>("/search/neural_code", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("NeuralCodeSearch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// /search/tag_based [POST] This will run our tag based search, and return the assets that best match your passed in tags. This will simply return FlattenedAssets, but will just be the assetuuids that match.
        /// </summary>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="seededAssetTags"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>SearchedAssets</returns>
        public SearchedAssets TagBasedSearch(bool? pseudo = default(bool?), SeededAssetTags seededAssetTags = default(SeededAssetTags), int operationIndex = 0)
        {
            Pieces.Os.Core.Client.ApiResponse<SearchedAssets> localVarResponse = TagBasedSearchWithHttpInfo(pseudo, seededAssetTags);
            return localVarResponse.Data;
        }

        /// <summary>
        /// /search/tag_based [POST] This will run our tag based search, and return the assets that best match your passed in tags. This will simply return FlattenedAssets, but will just be the assetuuids that match.
        /// </summary>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="seededAssetTags"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of SearchedAssets</returns>
        public Pieces.Os.Core.Client.ApiResponse<SearchedAssets> TagBasedSearchWithHttpInfo(bool? pseudo = default(bool?), SeededAssetTags seededAssetTags = default(SeededAssetTags), int operationIndex = 0)
        {
            Pieces.Os.Core.Client.RequestOptions localVarRequestOptions = new Pieces.Os.Core.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/plain"
            };

            var localVarContentType = Pieces.Os.Core.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Pieces.Os.Core.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (pseudo != null)
            {
                localVarRequestOptions.QueryParameters.Add(Pieces.Os.Core.Client.ClientUtils.ParameterToMultiMap("", "pseudo", pseudo));
            }
            localVarRequestOptions.Data = seededAssetTags;

            localVarRequestOptions.Operation = "SearchApi.TagBasedSearch";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = this.Client.Post<SearchedAssets>("/search/tag_based", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("TagBasedSearch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// /search/tag_based [POST] This will run our tag based search, and return the assets that best match your passed in tags. This will simply return FlattenedAssets, but will just be the assetuuids that match.
        /// </summary>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="seededAssetTags"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SearchedAssets</returns>
        public async System.Threading.Tasks.Task<SearchedAssets> TagBasedSearchAsync(bool? pseudo = default(bool?), SeededAssetTags seededAssetTags = default(SeededAssetTags), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Pieces.Os.Core.Client.ApiResponse<SearchedAssets> localVarResponse = await TagBasedSearchWithHttpInfoAsync(pseudo, seededAssetTags, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// /search/tag_based [POST] This will run our tag based search, and return the assets that best match your passed in tags. This will simply return FlattenedAssets, but will just be the assetuuids that match.
        /// </summary>
        /// <exception cref="Pieces.Os.Core.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pseudo">This is helper boolean that will give you the ability to also include your pseudo assets, we will always default to false. (optional)</param>
        /// <param name="seededAssetTags"> (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SearchedAssets)</returns>
        public async System.Threading.Tasks.Task<Pieces.Os.Core.Client.ApiResponse<SearchedAssets>> TagBasedSearchWithHttpInfoAsync(bool? pseudo = default(bool?), SeededAssetTags seededAssetTags = default(SeededAssetTags), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Pieces.Os.Core.Client.RequestOptions localVarRequestOptions = new Pieces.Os.Core.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "text/plain"
            };

            var localVarContentType = Pieces.Os.Core.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Pieces.Os.Core.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (pseudo != null)
            {
                localVarRequestOptions.QueryParameters.Add(Pieces.Os.Core.Client.ClientUtils.ParameterToMultiMap("", "pseudo", pseudo));
            }
            localVarRequestOptions.Data = seededAssetTags;

            localVarRequestOptions.Operation = "SearchApi.TagBasedSearch";
            localVarRequestOptions.OperationIndex = operationIndex;


            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<SearchedAssets>("/search/tag_based", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("TagBasedSearch", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
