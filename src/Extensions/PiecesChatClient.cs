using System.Runtime.CompilerServices;
using Microsoft.Extensions.AI;
using Pieces.Os.Core.SdkModel;
using Pieces.OS.Client;
using Pieces.OS.Client.Copilot;

namespace Pieces.Extensions.AI;

public class PiecesChatClient(IPiecesClient piecesClient, Model? model = null) : IChatClient
{
    private readonly IPiecesClient piecesClient = piecesClient;
    private Model? model = model;
    private IPiecesCopilot? piecesCopilot;

    /// <inheritdoc />
    public ChatClientMetadata Metadata => new ChatClientMetadata("Pieces for Developers", new Uri("https://pieces.app"), (model?.Name) ?? "Unknown model");

    //
    // Summary:
    //     Sends chat messages to the model and returns the response messages.
    //
    // Parameters:
    //   chatMessages:
    //     The chat content to send.
    //
    //   options:
    //     The chat options to configure the request. To use Pieces specific features, set the following
    //     in the AdditionalProperties collection:
    //
    //     ["LiveContext"] = true/false; // set to true to use live context. Default to false.
    //     ["LiveContextTimeSpan"] = TimeSpan?; // The timespan to use for live context. Defaults to 15 minutes if not set.
    //     ["AssetIds"] = [];  // Set to an enumerable of asset ids to use saved assets in the chat. Default to none.
    //
    //   cancellationToken:
    //     The System.Threading.CancellationToken to monitor for cancellation requests.
    //     The default is System.Threading.CancellationToken.None.
    //
    // Returns:
    //     The response messages generated by the client.
    //
    // Remarks:
    //     The returned messages will not have been added to chatMessages. However, any
    //     intermediate messages generated implicitly by the client, including any messages
    //     for roundtrips to the model as part of the implementation of this request, will
    //     be included.
    public async Task<ChatCompletion> CompleteAsync(IList<ChatMessage> chatMessages, ChatOptions? options = null, CancellationToken cancellationToken = default)
    {   
        // Build the seeds
        var seeds = GetSeedsFromChatMessages(chatMessages);
        // Check that the last message is from the user - if not we don't have a question to ask.
        var last = seeds.Last();
        // Remove the last, as this is passed as the question
        seeds.Remove(last);

        // Create the chat
        var chat = await CreateChatAsync(options, seeds, cancellationToken).ConfigureAwait(false);

        // Ask the question
        var response = await chat.AskQuestionAsync(last.Message, 
                                                   liveContextTimeSpan: GetLiveContextTimeSpanFromOptions(options), 
                                                   cancellationToken: cancellationToken).ConfigureAwait(false);

        // Build the response
        return new ChatCompletion([new ChatMessage(ChatRole.Assistant, response)])
        {
            ModelId = chat.Model.Id,
            FinishReason = ChatFinishReason.Stop,
            CompletionId = chat.Id,
        };
    }

    private static IEnumerable<string>? GetAssetIdsFromOptions(ChatOptions? options)
    {
        if (options is not null && options.AdditionalProperties is not null)
        {
            if (options!.AdditionalProperties!.TryGetValue("AssetIds", out object? assetIdsVal))
            {
                return assetIdsVal as IEnumerable<string>;
            }
        }

        return null;
    }

    private static bool GetLiveContextFromOptions(ChatOptions? options)
    {
        if (options is not null && options.AdditionalProperties is not null)
        {
            if (options!.AdditionalProperties!.TryGetValue("LiveContext", out object? liveContextVal))
            {
                return liveContextVal is bool v && v;
            }
        }

        return false;
    }

    private static TimeSpan? GetLiveContextTimeSpanFromOptions(ChatOptions? options)
    {
        if (options is not null && options.AdditionalProperties is not null)
        {
            if (options!.AdditionalProperties!.TryGetValue("LiveContextTimeSpan", out object? liveContextTimeSpanVal))
            {
                return liveContextTimeSpanVal as TimeSpan?;
            }
        }

        return null;
    }

    private static List<SeedMessage> GetSeedsFromChatMessages(IList<ChatMessage> chatMessages)
    {
        // Validate the chat messages - we need at least one, and the last should be a user message
        if (!chatMessages.Any())
        {
            throw new ArgumentException("No chat messages provided", nameof(chatMessages));
        }

        if (!chatMessages.Last().Role.Equals(ChatRole.User))
        {
            throw new PiecesClientException($"The last messages is expected to be a user message as this is the question that will be asked. It is a {chatMessages.Last().Role} message.");
        }

        return chatMessages.Select(c =>
        {
            var role = c.Role switch
            {
                ChatRole when c.Role == ChatRole.System => QGPTConversationMessageRoleEnum.SYSTEM,
                ChatRole when c.Role == ChatRole.User => QGPTConversationMessageRoleEnum.USER,
                _ => QGPTConversationMessageRoleEnum.ASSISTANT,
            };
            return new SeedMessage(role, c.Text!);
        }).ToList();
    }

    private async Task<Model?> GetModelFromChatOptionsAsync(ChatOptions? options, CancellationToken cancellationToken)
    {
        // If we have a model ID, get that model
        // Otherwise use the last one set
        return (options?.ModelId) switch
        {
            not null => await piecesClient.DownloadModelAsync(options!.ModelId!, cancellationToken).ConfigureAwait(false),
            _ => model
        };
    }

    /// <inheritdoc />
    public async IAsyncEnumerable<StreamingChatCompletionUpdate> CompleteStreamingAsync(IList<ChatMessage> chatMessages, 
                                                                                        ChatOptions? options = null, 
                                                                                        [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        // Build the seeds
        var seeds = GetSeedsFromChatMessages(chatMessages);
        // Check that the last message is from the user - if not we don't have a question to ask.
        var last = seeds.Last();
        // Remove the last, as this is passed as the question
        seeds.Remove(last);

        // Create the chat
        var chat = await CreateChatAsync(options, seeds, cancellationToken).ConfigureAwait(false);

        // Ask the question
        await foreach (var r in chat.AskStreamingQuestionAsync(last.Message, 
                                                               liveContextTimeSpan: GetLiveContextTimeSpanFromOptions(options), 
                                                               cancellationToken: cancellationToken))
        {
            var response = new StreamingChatCompletionUpdate()
            {
                Text = r,
                CompletionId = chat.Id,
                Role = ChatRole.Assistant
            };

            yield return response;
        }
    }

    private async Task<ICopilotChat> CreateChatAsync(ChatOptions? options, List<SeedMessage> seeds, CancellationToken cancellationToken)
    {
        // Ensure the copilot has been created
        piecesCopilot ??= await piecesClient.GetCopilotAsync().ConfigureAwait(false);

        // extract the relevant properties from the options
        model = await GetModelFromChatOptionsAsync(options, cancellationToken).ConfigureAwait(false);
        var assetIds = GetAssetIdsFromOptions(options);
        var liveContext = GetLiveContextFromOptions(options);

        // Create a new chat using all the messages that have been sent
        return await piecesCopilot.CreateSeededChatAsync("",
                                                        model: model,
                                                        seeds: seeds,
                                                        assetIds: assetIds,
                                                        useLiveContext: liveContext,
                                                        cancellationToken: cancellationToken).ConfigureAwait(false);
    }

    /// <inheritdoc />
    public void Dispose()
    {
        GC.SuppressFinalize(this);
    }

    /// <inheritdoc />
    public TService? GetService<TService>(object? key = null)
        where TService : class
        => key is null ? this as TService : null;
}